<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Stone Grimoire — Musical Cubes Visual Lab</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="description" content="Museum-grade visual study of Rosslyn cube motifs: PD photo overlay, edge extraction, pattern families, and cymatic-style Lissajous comparison with YAML export.">
<link rel="stylesheet" href="../assets/css/palette.css">
<link rel="stylesheet" href="../assets/css/light.css">
<script src="../assets/js/theme.js" defer></script>
<script src="../assets/js/planetary-light.js" defer></script>
<style>
  body.mystic{background:radial-gradient(circle at 50% 20%, var(--bg) 78%, #ece7dc 100%); color:var(--ink); font:18px/1.6 Georgia,serif}
  .wrap{max-width:1150px;margin:0 auto;padding:18px}
  header{display:flex;justify-content:space-between;align-items:center;gap:12px}
  h1{margin:.2rem 0;color:var(--accent)}
  .meta{color:#6b6257;font-size:.95rem}
  .grid{display:grid;grid-template-columns:1.05fr .95fr;gap:14px}
  @media (max-width:1080px){ .grid{grid-template-columns:1fr} }
  .panel{background:var(--panel);border:1px solid var(--line);border-radius:12px;padding:12px}
  .controls{display:grid;grid-template-columns:repeat(2,1fr);gap:10px}
  @media (max-width:720px){ .controls{grid-template-columns:1fr} }
  label{font-size:.9rem;color:#3d3a34;display:block}
  input,select,textarea{width:100%;padding:8px;border:1px solid var(--line);border-radius:8px;background:#fff;font:inherit}
  textarea{min-height:140px}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .btn{border:0;border-radius:10px;padding:8px 12px;cursor:pointer;font:inherit}
  .btn.primary{background:var(--accent);color:#fff}
  .btn.ghost{background:#fff;border:1px solid var(--line);color:#2b2520}
  .canvas-wrap{position:relative;border:1px solid var(--line);border-radius:12px;overflow:hidden;background:#fff}
  canvas{display:block;width:100%;height:auto}
  .note{font-size:.9rem;color:#6b6257;margin-top:6px}
  .badge{display:inline-block;padding:.1rem .5rem;border:1px solid var(--line);border-radius:999px;font-size:.8rem;margin-right:.3rem}
  #live{position:absolute;left:-9999px}
</style>
</head>
<body class="mystic" data-theme="tiphereth">
<div class="wrap">
  <header>
    <div>
      <h1>Musical Cubes — Visual Study Lab</h1>
      <div class="meta">Museum grade: PD/own photos only. Edges extracted for carving clarity. Compare to pattern families or cymatic-style Lissajous. Export provenance YAML.</div>
    </div>
    <div class="meta"><a href="../images/pd/index.html">PD Image Library</a> · <a href="../chapels/cubes-catalog.html">Cubes Catalog</a> · <a href="../cathedral.html">Nave</a></div>
  </header>

  <div id="live" aria-live="polite"></div>

  <div class="grid">
    <!-- LEFT: Overlay & Edges -->
    <section class="panel" aria-label="Overlay & Edge Extraction">
      <h2 class="mystic-title">1) Photo Overlay (Public‑Domain or Yours)</h2>
      <div class="controls">
        <div>
          <label for="imgUrl">Photo URL (PD/CC or yours)</label>
          <input id="imgUrl" type="url" placeholder="https://… (PD engraving or your photo)">
        </div>
        <div>
          <label for="imgFile">Or upload image</label>
          <input id="imgFile" type="file" accept="image/*">
        </div>
        <div>
          <label for="opacity">Overlay opacity</label>
          <input id="opacity" type="range" min="0" max="1" step="0.01" value="0.55">
        </div>
        <div>
          <label for="threshold">Edge threshold</label>
          <input id="threshold" type="range" min="0" max="255" step="1" value="90">
        </div>
        <div>
          <label for="rot">Rotate (deg)</label>
          <input id="rot" type="range" min="-180" max="180" step="1" value="0">
        </div>
        <div>
          <label for="scale">Scale</label>
          <input id="scale" type="range" min="0.25" max="3" step="0.01" value="1">
        </div>
        <div>
          <label for="offsetX">Offset X</label>
          <input id="offsetX" type="range" min="-400" max="400" step="1" value="0">
        </div>
        <div>
          <label for="offsetY">Offset Y</label>
          <input id="offsetY" type="range" min="-400" max="400" step="1" value="0">
        </div>
      </div>

      <div class="row" style="margin-top:8px">
        <button class="btn ghost" id="toggleGrid" aria-pressed="true">Grid: On</button>
        <button class="btn ghost" id="toggleEdges" aria-pressed="true">Edges: On</button>
        <button class="btn ghost" id="resetView">Reset View</button>
      </div>
      <p class="note">Use a **Public‑Domain** engraving/old photo (see PD Library) or your own image. This tool never claims exact Hz; it’s a visual comparator for families of patterns.</p>

      <div class="canvas-wrap" style="margin-top:8px">
        <canvas id="overlayCanvas" width="800" height="800" role="img" aria-label="Overlay image with edge extraction and grid"></canvas>
      </div>
    </section>

    <!-- RIGHT: Pattern families & Comparison -->
    <section class="panel" aria-label="Pattern Families & Cymatics">
      <h2 class="mystic-title">2) Pattern Generator (Family or Cymatic)</h2>
      <div class="controls">
        <div>
          <label for="family">Family</label>
          <select id="family">
            <option value="rings">Rings (concentric)</option>
            <option value="cross">Cross (nodal)</option>
            <option value="bars">Bars (n)</option>
            <option value="lattice">Lattice (X)</option>
            <option value="diamond">Diamond grid</option>
            <option value="rosette">Rosette (petals)</option>
            <option value="lissajous">Cymatic-style Lissajous</option>
          </select>
        </div>
        <div>
          <label for="param1">Param 1</label>
          <input id="param1" type="range" min="1" max="12" step="1" value="2">
        </div>
        <div>
          <label for="param2">Param 2</label>
          <input id="param2" type="range" min="0" max="12" step="1" value="0">
        </div>
        <div>
          <label for="genRot">Rotation (deg)</label>
          <input id="genRot" type="range" min="0" max="180" step="1" value="0">
        </div>
      </div>
      <p class="note">Examples: Rings→Param1=2 (two rings). Bars→Param1=3 (trigram). Rosette→Param1=6 (petals). Lissajous→Param1=a, Param2=b.</p>

      <div class="canvas-wrap" style="margin-top:8px">
        <canvas id="patternCanvas" width="800" height="800" role="img" aria-label="Generated pattern for comparison"></canvas>
      </div>

      <h2 class="mystic-title" style="margin-top:10px">3) Compare & Document</h2>
      <div class="controls">
        <div>
          <label for="blend">Blend (Overlay ↔ Pattern)</label>
          <input id="blend" type="range" min="0" max="1" step="0.01" value="0.5">
        </div>
        <div>
          <label for="cubeId">Catalog ID (e.g., RCH-Q1-001)</label>
          <input id="cubeId" type="text" placeholder="RCH-Q1-001">
        </div>
        <div>
          <label for="motif">Motif (plain description)</label>
          <input id="motif" type="text" placeholder="Concentric double ring with central boss">
        </div>
        <div>
          <label for="credit">Image credit</label>
          <input id="credit" type="text" placeholder="Unknown engraver, c. 1840">
        </div>
      </div>

      <div class="row" style="margin-top:8px">
        <button class="btn primary" id="exportYAML">Export YAML</button>
        <button class="btn ghost" id="savePNG">Save Snapshot (PNG)</button>
      </div>
      <textarea id="yamlOut" aria-label="YAML export"></textarea>
      <p class="note">YAML goes into <code>data/cubes.yml</code>. Set <span class="badge">status: attested</span> (photo), <span class="badge">schematic</span> (trace), or <span class="badge">interpretive</span> (commentary).</p>
    </section>
  </div>

  <section class="panel" style="margin-top:12px">
    <h2 class="mystic-title">Policy</h2>
    <ul class="meta">
      <li><strong>Images:</strong> Public Domain (pre‑1929) or your own photos. For CC BY/SA, include author + license in the credit line.</li>
      <li><strong>Claims:</strong> This tool compares families of forms. Do not assert exact frequencies without rigorous method; label such work as **interpretive**.</li>
    </ul>
  </section>
</div>

<script>
(function(){
  const live = (msg)=>{ const el = document.getElementById('live'); el.textContent = msg; };

  // ---- CANVASES
  const oCan = document.getElementById('overlayCanvas'); const oCtx = oCan.getContext('2d');
  const pCan = document.getElementById('patternCanvas'); const pCtx = pCan.getContext('2d');

  const state = {
    img: null, opacity: 0.55, threshold: 90,
    rot: 0, scale: 1, dx:0, dy:0, showGrid:true, showEdges:true,
    family: 'rings', param1:2, param2:0, genRot:0, blend:0.5
  };

  // ---- LOAD IMAGE (URL or upload)
  document.getElementById('imgUrl').addEventListener('change', e=>{
    const url = e.target.value.trim(); if(!url) return;
    loadImage(url);
  });
  document.getElementById('imgFile').addEventListener('change', e=>{
    const f = e.target.files[0]; if(!f) return;
    const url = URL.createObjectURL(f); loadImage(url);
  });

  function loadImage(src){
    const img = new Image(); img.crossOrigin='anonymous';
    img.onload = ()=>{ state.img = img; fitToCanvas(); drawOverlay(); live('Image loaded.'); };
    img.onerror = ()=> live('Could not load that image (CORS or bad link). Try downloading PD image into /images/pd and using a relative URL.');
    img.src = src;
  }

  function fitToCanvas(){
    if(!state.img) return;
    // simple fit: center & scale to canvas size
    const W = oCan.width, H = oCan.height;
    const iw = state.img.width, ih = state.img.height;
    const s = Math.min(W/iw, H/ih)*0.9;
    state.scale = s; state.dx = 0; state.dy = 0; state.rot = 0;
    syncControls();
  }

  // ---- CONTROLS (overlay)
  const opacity = document.getElementById('opacity');
  const threshold = document.getElementById('threshold');
  const rot = document.getElementById('rot');
  const scale = document.getElementById('scale');
  const offsetX = document.getElementById('offsetX');
  const offsetY = document.getElementById('offsetY');
  [opacity,threshold,rot,scale,offsetX,offsetY].forEach(el=>el.addEventListener('input', ()=>{
    state.opacity = parseFloat(opacity.value);
    state.threshold = parseInt(threshold.value,10);
    state.rot = parseInt(rot.value,10)*Math.PI/180;
    state.scale = parseFloat(scale.value);
    state.dx = parseInt(offsetX.value,10);
    state.dy = parseInt(offsetY.value,10);
    drawOverlay();
  }));

  document.getElementById('toggleGrid').addEventListener('click', (e)=>{
    state.showGrid = !state.showGrid; e.target.setAttribute('aria-pressed', String(state.showGrid));
    e.target.textContent = 'Grid: ' + (state.showGrid?'On':'Off'); drawOverlay();
  });
  document.getElementById('toggleEdges').addEventListener('click', (e)=>{
    state.showEdges = !state.showEdges; e.target.setAttribute('aria-pressed', String(state.showEdges));
    e.target.textContent = 'Edges: ' + (state.showEdges?'On':'Off'); drawOverlay();
  });
  document.getElementById('resetView').addEventListener('click', ()=>{
    fitToCanvas(); opacity.value='0.55'; threshold.value='90'; rot.value='0'; scale.value=state.scale; offsetX.value='0'; offsetY.value='0';
    state.opacity=.55; state.threshold=90; state.rot=0; state.dx=0; state.dy=0; drawOverlay();
  });

  // drag to move
  let dragging=false, last=null;
  oCan.addEventListener('pointerdown', (e)=>{ dragging=true; last={x:e.clientX,y:e.clientY}; oCan.setPointerCapture(e.pointerId); });
  oCan.addEventListener('pointermove', (e)=>{
    if(!dragging) return;
    const dx=e.clientX-last.x, dy=e.clientY-last.y; last={x:e.clientX,y:e.clientY};
    state.dx += dx; state.dy += dy; offsetX.value=state.dx; offsetY.value=state.dy; drawOverlay();
  });
  oCan.addEventListener('pointerup', ()=> dragging=false);

  // ---- DRAW OVERLAY with edges & grid
  function drawOverlay(){
    const W=oCan.width, H=oCan.height;
    oCtx.clearRect(0,0,W,H);
    // grid
    if(state.showGrid){
      oCtx.save();
      oCtx.strokeStyle = '#d9cfbf'; oCtx.lineWidth=1;
      for(let x=0;x<=W;x+=100){ oCtx.beginPath(); oCtx.moveTo(x,0); oCtx.lineTo(x,H); oCtx.stroke(); }
      for(let y=0;y<=H;y+=100){ oCtx.beginPath(); oCtx.moveTo(0,y); oCtx.lineTo(W,y); oCtx.stroke(); }
      oCtx.restore();
    }
    if(!state.img) return;
    // transformed draw
    oCtx.save();
    oCtx.translate(W/2 + state.dx, H/2 + state.dy);
    oCtx.rotate(state.rot);
    oCtx.scale(state.scale, state.scale);
    oCtx.globalAlpha = state.opacity;
    oCtx.drawImage(state.img, -state.img.width/2, -state.img.height/2);
    oCtx.restore();

    if(state.showEdges) drawEdges();
    drawPattern(); // for blend display
  }

  // ---- SOBEL EDGE EXTRACTION
  function drawEdges(){
    // draw the transformed image into a temp canvas to extract edges in place
    const W=oCan.width, H=oCan.height;
    const tmp=document.createElement('canvas'); tmp.width=W; tmp.height=H;
    const tctx=tmp.getContext('2d');
    // paint transformed image opaque for edge extraction
    tctx.save();
    tctx.translate(W/2 + state.dx, H/2 + state.dy);
    tctx.rotate(state.rot);
    tctx.scale(state.scale, state.scale);
    tctx.drawImage(state.img, -state.img.width/2, -state.img.height/2);
    tctx.restore();

    const imgData = tctx.getImageData(0,0,W,H);
    const gray = new Uint8ClampedArray(W*H);
    for(let i=0,j=0;i<imgData.data.length;i+=4,j++){ // grayscale
      const r=imgData.data[i], g=imgData.data[i+1], b=imgData.data[i+2];
      gray[j] = (r*0.299 + g*0.587 + b*0.114)|0;
    }
    const edge = sobel(gray, W, H);
    const out = oCtx.createImageData(W,H);
    for(let i=0;i<edge.length;i++){
      const v = edge[i] > state.threshold ? 0 : 255; // invert: edges dark
      out.data[i*4+0]=v; out.data[i*4+1]=v; out.data[i*4+2]=v; out.data[i*4+3]=180;
    }
    oCtx.putImageData(out,0,0);
  }

  function sobel(gray, W, H){
    const out = new Uint16Array(W*H);
    const gx=[-1,0,1,-2,0,2,-1,0,1];
    const gy=[-1,-2,-1,0,0,0,1,2,1];
    for(let y=1;y<H-1;y++){
      for(let x=1;x<W-1;x++){
        let sx=0, sy=0, idx=0;
        for(let j=-1;j<=1;j++){
          for(let i=-1;i<=1;i++){
            const p = (y+j)*W + (x+i);
            sx += gray[p]*gx[idx]; sy += gray[p]*gy[idx]; idx++;
          }
        }
        const mag = Math.min(255, Math.hypot(sx, sy)|0);
        out[y*W+x] = mag;
      }
    }
    return out;
  }

  // ---- PATTERN GENERATOR
  const family = document.getElementById('family');
  const param1 = document.getElementById('param1');
  const param2 = document.getElementById('param2');
  const genRot = document.getElementById('genRot');
  [family,param1,param2,genRot].forEach(el=> el.addEventListener('input', ()=>{ 
    state.family=family.value; state.param1=parseInt(param1.value,10); state.param2=parseInt(param2.value,10);
    state.genRot=parseInt(genRot.value,10)*Math.PI/180; drawPattern(); 
  }));

  function drawPattern(){
    const W=pCan.width, H=pCan.height;
    pCtx.clearRect(0,0,W,H);
    pCtx.save();
    pCtx.translate(W/2, H/2);
    pCtx.rotate(state.genRot);
    pCtx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--accent').trim()||'#2f5a9e';
    pCtx.lineWidth=2;

    const R=Math.min(W,H)*0.35;
    switch(state.family){
      case 'rings': {
        for(let i=1;i<=state.param1;i++){
          pCtx.beginPath(); pCtx.arc(0,0,(R*i)/(state.param1+0.5),0,Math.PI*2); pCtx.stroke();
        } break;
      }
      case 'cross': {
        pCtx.beginPath(); pCtx.moveTo(0,-R); pCtx.lineTo(0,R); pCtx.moveTo(-R,0); pCtx.lineTo(R,0); pCtx.stroke();
        break;
      }
      case 'bars': {
        const n=Math.max(1,state.param1);
        for(let i=0;i<n;i++){
          const y = -R + (2*R)*(i/(n-1||1));
          pCtx.beginPath(); pCtx.moveTo(-R,y); pCtx.lineTo(R,y); pCtx.stroke();
        }
        break;
      }
      case 'lattice': {
        pCtx.beginPath(); pCtx.moveTo(-R,-R); pCtx.lineTo(R,R); pCtx.moveTo(-R,R); pCtx.lineTo(R,-R); pCtx.stroke();
        break;
      }
      case 'diamond': {
        pCtx.beginPath(); pCtx.moveTo(0,-R); pCtx.lineTo(R,0); pCtx.lineTo(0,R); pCtx.lineTo(-R,0); pCtx.closePath(); pCtx.stroke();
        if(state.param1>1){
          const r2=R*0.6;
          pCtx.beginPath(); pCtx.moveTo(0,-r2); pCtx.lineTo(r2,0); pCtx.lineTo(0,r2); pCtx.lineTo(-r2,0); pCtx.closePath(); pCtx.stroke();
        }
        break;
      }
      case 'rosette': {
        const petals=Math.max(3,state.param1);
        pCtx.beginPath();
        for(let i=0;i<=360;i++){
          const t=i*Math.PI/180;
          const k=petals;
          const rr = R*0.65*Math.cos(k*t);
          const x = rr*Math.cos(t), y=rr*Math.sin(t);
          if(i===0) pCtx.moveTo(x,y); else pCtx.lineTo(x,y);
        }
        pCtx.stroke(); break;
      }
      case 'lissajous': {
        const a=Math.max(1,state.param1), b=Math.max(1,Math.max(1,state.param2));
        pCtx.beginPath();
        for(let i=0;i<=720;i++){
          const t=i*Math.PI/180;
          const x = R*0.8*Math.sin(a*t);
          const y = R*0.8*Math.sin(b*t);
          if(i===0) pCtx.moveTo(x,y); else pCtx.lineTo(x,y);
        }
        pCtx.stroke(); break;
      }
    }
    pCtx.restore();
    drawBlend();
  }

  // ---- BLEND VIEW (overlay vs pattern)
  const blend = document.getElementById('blend');
  blend.addEventListener('input', ()=>{ state.blend=parseFloat(blend.value); drawBlend(); });

  function drawBlend(){
    // composite onto overlay canvas top‑right corner? Better: draw a blended preview over the pattern canvas border area.
    // We’ll overlay a thumbnail of edges onto pattern canvas with alpha = blend.
    const W=pCan.width, H=pCan.height;
    // redraw pattern already present; now draw overlay edges ghosted using oCan pixels
    const img = oCtx.getImageData(0,0,oCan.width,oCan.height);
    // scale edges data to fit pattern canvas
    const tmp=document.createElement('canvas'); tmp.width=oCan.width; tmp.height=oCan.height;
    tmp.getContext('2d').putImageData(img,0,0);
    pCtx.save();
    pCtx.globalAlpha = state.blend;
    pCtx.drawImage(tmp,0,0,W,H);
    pCtx.restore();
  }

  function syncControls(){
    document.getElementById('scale').value = state.scale;
    document.getElementById('offsetX').value = state.dx;
    document.getElementById('offsetY').value = state.dy;
  }

  // ---- YAML EXPORT + SNAPSHOT
  document.getElementById('exportYAML').addEventListener('click', ()=>{
    const id = (document.getElementById('cubeId').value||'RCH-NEW').trim();
    const motif = (document.getElementById('motif').value||'').trim();
    const credit = (document.getElementById('credit').value||'').trim();
    const url = (document.getElementById('imgUrl').value||'').trim();
    const yaml = [
      '# Append to data/cubes.yml',
      'cubes:',
      `  - id: ${id}`,
      `    location: ""`,
      `    motif: "${motif}"`,
      `    status: "attested"`,
      '    photo:',
      `      url: "${url}"`,
      `      credit: "${credit}"`,
      `      license: "Public Domain / CC (verify)"`,
      `    schematic: ""`,
      `    notes: "Visual match via family: ${state.family} (p1=${state.param1}${state.family==='lissajous'?`, p2=${state.param2}`:''}); overlay rot=${(state.rot*180/Math.PI).toFixed(1)}°, scale=${state.scale.toFixed(2)}, dx=${state.dx}, dy=${state.dy}. Edge threshold=${state.threshold}."`,
      `    comparisons:`,
      `      - type: "cymatic-family"`,
      `        note: "${state.family}${state.family==='lissajous'?` a:${state.param1} b:${state.param2}`:''} (family resemblance; no exact Hz claimed)."`
    ].join('\n');
    document.getElementById('yamlOut').value = yaml;
    live('YAML prepared.');
  });

  document.getElementById('savePNG').addEventListener('click', ()=>{
    // Compose a snapshot: pattern canvas with blended edges already drawn
    const link = document.createElement('a');
    link.download = 'cubes-visual-study.png';
    link.href = pCan.toDataURL('image/png');
    link.click();
    live('Snapshot saved.');
  });

  // ---- On load: use #overlay= URL if present
  const fromHash = new URLSearchParams(location.hash.slice(1)).get('overlay');
  if(fromHash){ document.getElementById('imgUrl').value = fromHash; loadImage(fromHash); }

  // init
  drawOverlay(); drawPattern();
})();
</script>
</body>
</html>
