<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Cosmic Helix Renderer (ND-safe, Offline)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
  <meta name="color-scheme" content="dark light">
  <style>
    /* ND-safe glass/dark shell: static gradients, no motion, high contrast. */
    :root {
      --bg:#0b0b12;
      --ink:#e8e8f0;
      --muted:#a6a6c1;
      --frame:#1d1d2a;
      --glaze:#151523;
      --accent:#8fb4ff;
      --fallback:#f2c27d;
      --minimal:#f59aa7;
    }

    * {
      box-sizing:border-box;
    }

    html,body {
      margin:0;
      padding:0;
      min-height:100%;
      background:var(--bg);
      color:var(--ink);
      font:15px/1.5 "Segoe UI",Roboto,system-ui,sans-serif;
    }

    body {
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:16px;
      padding:16px;
      position:relative;
    }

    .visually-hidden {
      position:absolute;
      width:1px;
      height:1px;
      padding:0;
      margin:-1px;
      overflow:hidden;
      clip:rect(0 0 0 0);
      white-space:nowrap;
      border:0;
    }

    body::before {
      /* Glass wash overlay to keep depth without motion. */
      content:"";
      position:fixed;
      inset:0;
      background:radial-gradient(circle at 20% 20%,rgba(143,180,255,0.12),transparent 45%),
        radial-gradient(circle at 80% 15%,rgba(245,163,255,0.10),transparent 40%),
        linear-gradient(135deg,rgba(21,21,35,0.85),rgba(11,11,18,0.92));
      pointer-events:none;
      z-index:-2;
    }

    body::after {
      /* Quiet gridded glint for stained-glass impression. */
      content:"";
      position:fixed;
      inset:0;
      background:linear-gradient(90deg,rgba(255,255,255,0.03) 0, rgba(255,255,255,0.01) 50%, transparent 50%),
        linear-gradient(0deg,rgba(255,255,255,0.02) 0, transparent 55%);
      background-size:140px 140px;
      mix-blend-mode:screen;
      opacity:0.45;
      pointer-events:none;
      z-index:-3;
    }

    header,
    .surface {
      width:min(960px, 100%);
      border:1px solid var(--frame);
      border-radius:18px;
      padding:18px;
      background:linear-gradient(155deg,rgba(15,16,28,0.85),rgba(11,11,18,0.9));
      box-shadow:0 18px 40px rgba(4,5,12,0.65);
    }

    @supports (backdrop-filter: blur(14px)) {
      header,
      .surface {
        backdrop-filter:blur(18px);
        background:rgba(15,16,28,0.72);
      }
    }

    header {
      display:flex;
      flex-direction:column;
      gap:6px;
      text-align:left;
    }

    header strong {
      letter-spacing:0.12em;
      text-transform:uppercase;
      font-size:12px;
      color:var(--accent);
    }

    .status {
      margin:0;
      font-size:13px;
      color:var(--muted);
    }

    [data-mode="fallback"] .status {
      color:var(--fallback);
    }

    [data-mode="minimal"] .status {
      color:var(--minimal);
    }

    main {
      width:100%;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:18px;
    }

    .surface {
      display:flex;
      flex-direction:column;
      gap:14px;
      align-items:center;
    }

    #stage {
      display:block;
      width:100%;
      max-width:1440px;
      height:auto;
      border-radius:12px;
      box-shadow:0 0 0 1px var(--frame);
      background:var(--glaze);
    }

    .notice {
      margin:0;
      padding:10px 14px;
      width:100%;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.12);
      background:rgba(20,20,34,0.85);
      color:var(--fallback);
      font-size:13px;
    }

    .note {
      max-width:960px;
      margin:0;
      color:var(--muted);
      font-size:13px;
      text-align:center;
    }

    .note strong {
      color:var(--ink);
    }

    a {
      color:var(--accent);
      text-decoration:none;
    }

    a:hover,
    a:focus {
      text-decoration:underline;
    }
  </style>
</head>
<body data-mode="loading">
  <header>
    <div><strong>Cosmic Helix Renderer</strong> — layered sacred geometry (offline, ND-safe)</div>
    <p class="status" id="status" role="status" aria-live="polite">Calibrating palette…</p>
  </header>

  <main role="main">
    <section class="surface" aria-labelledby="canvas-title">
      <h1 id="canvas-title" class="visually-hidden">Layered sacred geometry canvas</h1>
      <canvas id="stage" width="1440" height="900" aria-describedby="canvas-note"></canvas>
      <p id="notice" class="notice" role="status" aria-live="polite" hidden></p>
    </section>

    <p id="canvas-note" class="note">
      This static renderer honours four calm layers in order: <strong>Vesica field</strong>, <strong>Tree-of-Life scaffold</strong>, <strong>Fibonacci curve</strong>, and a <strong>double-helix lattice</strong>. Modes follow the implementation guide discipline — custom palette, fallback palette, or minimal fail-safe.
    </p>
  </main>

  <script type="module">
    import { renderHelix } from "./js/helix-renderer.mjs";

    const canvas = document.getElementById("stage");
    const ctx = canvas.getContext("2d");
    const statusEl = document.getElementById("status");
    const noticeEl = document.getElementById("notice");

    const DEFAULTS = {
      palette: {
        bg:"#0b0b12",
        ink:"#e8e8f0",
        muted:"#a6a6c1",
        layers:["#8fb4ff","#6fd0f2","#8ff0c4","#ffd7a6","#f3a8ff","#d9dcff"]
      }
    };

    const NUM = {
      THREE:3,
      SEVEN:7,
      NINE:9,
      ELEVEN:11,
      TWENTYTWO:22,
      THIRTYTHREE:33,
      NINETYNINE:99,
      ONEFORTYFOUR:144
    };

    const MODES = {
      CUSTOM:{ id:"custom", status:"Mode: Custom palette — data/palette.json loaded." },
      FALLBACK:{ id:"fallback", status:"Mode: Fallback palette — using internal ND-safe tones." },
      MINIMAL:{ id:"minimal", status:"Mode: Minimal — canvas context unavailable; geometry skipped." }
    };

    init();

    async function init() {
      const paletteState = await loadPalette("./data/palette.json", DEFAULTS.palette);
      applyShellPalette(paletteState.palette);
      setMode(paletteState.mode, paletteState.status);
      toggleNotice(paletteState.notice);

      if (!ctx) {
        setMode(MODES.MINIMAL);
        toggleNotice("Canvas context unavailable; the browser will still display the notes above.");
        return;
      }

      // ND-safe rationale: render once, preserve depth without motion.
      renderHelix(ctx, {
        width:canvas.width,
        height:canvas.height,
        palette:{
          bg:paletteState.palette.bg,
          ink:paletteState.palette.ink,
          layers:paletteState.palette.layers.slice()
        },
        NUM
      });
    }

    async function loadPalette(path, fallback) {
      try {
        const res = await fetch(path, { cache:"no-store" });
        if (!res.ok) throw new Error("HTTP " + res.status);
        const raw = await res.json();
        const { palette, valid } = normalisePalette(raw, fallback);
        if (!valid) {
          return {
            palette,
            mode:MODES.FALLBACK,
            status:"Mode: Fallback palette — palette file was incomplete; using internal ND-safe tones.",
            notice:"Palette file was missing required keys; using safe fallback palette."
          };
        }
        return {
          palette,
          mode:MODES.CUSTOM,
          status:MODES.CUSTOM.status
        };
      } catch (error) {
        const reason = window.location && window.location.protocol === "file:" ?
          "Browser blocked local palette fetch" : "Palette file unavailable";
        return {
          palette:{ ...fallback, layers:fallback.layers.slice() },
          mode:MODES.FALLBACK,
          status:MODES.FALLBACK.status,
          notice:reason + "; safe fallback palette applied."
        };
      }
    }

    function applyShellPalette(palette) {
      const root = document.documentElement.style;
      root.setProperty("--bg", palette.bg || DEFAULTS.palette.bg);
      root.setProperty("--ink", palette.ink || DEFAULTS.palette.ink);
      root.setProperty("--muted", palette.muted || palette.ink || DEFAULTS.palette.ink);
      document.body.style.background = palette.bg || DEFAULTS.palette.bg;
      document.body.style.color = palette.ink || DEFAULTS.palette.ink;
    }

    function setMode(mode, explicitStatus) {
      const target = mode || MODES.FALLBACK;
      document.body.setAttribute("data-mode", target.id);
      statusEl.textContent = explicitStatus || target.status;
    }

    function toggleNotice(message) {
      if (!message) {
        noticeEl.hidden = true;
        noticeEl.textContent = "";
        return;
      }
      noticeEl.hidden = false;
      noticeEl.textContent = message;
    }

    function normalisePalette(raw, fallback) {
      if (!raw || typeof raw !== "object") {
        return { palette:fallback, valid:false };
      }
      let valid = true;
      const layerState = normaliseLayers(raw.layers, fallback.layers);
      const palette = {
        bg: typeof raw.bg === "string" ? raw.bg : (valid = false, fallback.bg),
        ink: typeof raw.ink === "string" ? raw.ink : (valid = false, fallback.ink),
        muted: typeof raw.muted === "string" ? raw.muted : (raw.ink && typeof raw.ink === "string" ? raw.ink : fallback.ink),
        layers: layerState.layers
      };
      if (!layerState.valid) {
        valid = false;
      }
      return { palette:{ ...palette, layers:palette.layers.slice() }, valid };
    }

    function normaliseLayers(layers, fallbackLayers) {
      if (!Array.isArray(layers) || layers.length === 0) {
        return { layers:fallbackLayers.slice(), valid:false };
      }
      const cleaned = layers.filter(tone => typeof tone === "string");
      if (cleaned.length === 0) {
        return { layers:fallbackLayers.slice(), valid:false };
      }
      return { layers:cleaned.slice(), valid:true };
    }
  </script>
</body>
</html>
